<?php
include_once ('vsite.features.inc');

/**
 * Public Functions
 */

/**
 * Hooks
 */

/**
 * Implements hook_BASE_ID_form_alter().
 *
 * Runs on every node form
 */
function vsite_form_node_form_alter(&$form, &$form_state, $form_id){
  $vsite = spaces_get_space();
  $os_bundles = array_keys(os_get_bundles(true));
  
  if ($vsite && in_array($form['#bundle'], $os_bundles)) {
    //Set the og_group_ref value to automatically be the current active site
    $form[OG_AUDIENCE_FIELD][LANGUAGE_NONE][0]['target_id'] = array(
        '#type' => 'value',
        '#default_value' => $vsite->group->nid,
        '#field_name' => OG_AUDIENCE_FIELD,
        '#language' => LANGUAGE_NONE,
        '#entity_type' => 'node',
        '#bundle' => $form['#bundle']
    );
  }
  
  if(og_is_group_type('node',$form['#bundle'])){
    //Hide the comment settings form
    $form['comment_settings']['#access'] = false;
    $form['comment_settings']['comment']['#default_value'] = 1;
  }
}

/**
 * Alter the space presets to add vsite specific information
 *
 * @param $presets
 */
function vsite_spaces_presets_alter(&$presets){
  ctools_include('path', 'vsite');
  
  //Alter the preset to include the pathauto settings for nodes prefixed with the purl path
  $pathauto_settings = _vsite_get_pathauto_settings();
  foreach ( $presets as $name => &$preset ) {
    if (substr($name, 0, 3) == "os_") {
      $preset->value['variable'] = array_merge($pathauto_settings, $preset->value['variable']);
    }
  }
}

/**
 * Alter information returned from module/theme info files
 */
function vsite_system_info_alter(&$info, $file, $type){
  
  //Only alter the vsite info file
  if ($type != 'module' || $file->name != 'vsite')
    return;
    
  // Add the feature settings for the dynamically managed og reference fields
  if (! is_array($info['features']['field']))
    $info['features']['field'] = array();
  
  include_once ('vsite.features.field.inc');
  foreach ( vsite_get_group_fields() as $field => $definition ) {
    if (! in_array($field, $info['features']['field'])) {
      $info['features']['field'][] = $field;
    }
  }

}

/**
 * Implementation of hook spaces_plugins
 */
function vsite_spaces_plugins(){
  $plugins = array();
  $plugins['vsite'] = array(
    'handler' => array(
      'class' => 'vsite',
      'parent' => 'space_og'
    )
  );
  return $plugins;
}

/**
 * Implementation of hook registry_alter
 * Alter the registry to tell spaces_og groups to use the vsite plugin by default
 */
function vsite_spaces_registry_alter(&$registry){
  
  // use the vsite plugin by default
  if (isset($registry['types']['og'])) {
    $registry['types']['og']['plugin'] = 'vsite';
  }
}


/**
 * Handles access rules for when site owner is attempting to create a another site
 * @return  boolean
 */
function vsite_vsite_exists_access($vsites = array()){
  global $user;

  //load user's vsites.  anon (uid 0) has no vsites
	if (!$vsites && $user->uid) {  
	  ctools_include('vsite', 'vsite');
		$vsites = vsite_get_vsite_by_owner($user->uid);
	}

	//if user has permissions to create sites, return true
  if (!user_access('create vsite content on behalf') && !user_access('create vsite content')) {
    drupal_set_message(t('You do not have permission to create new sites.'), 'error', FALSE);
    return FALSE;
  }

  //user owns one or more sites
  if (!(count($vsites) < variable_get('os_vsites_per_user', 1) || user_access('create openscholar site on behalf of others'))) {
    drupal_set_message(t('You have already created the maximum of %num OS sites.', array('%num' => count($vsites))), 'error', FALSE);
    return FALSE;
  }

  return TRUE;
}


function vsite_permission() {
  return array(
    'create vsite content on behalf' => array(
      'title' => t('Create vsite content on behalf of other users'),
    )
  );
}